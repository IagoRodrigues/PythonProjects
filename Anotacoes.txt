Aula 5----------------------------------------------------------------------

Para escrever usamos print(). print() aceita vários parâmetros, incluindo
um separador e um end para colocar entre parâmetros:

print("O brasil", "possui", "5", "titulos mundiais", sep="-")
retorna: O brasil-possui-5-titulos mundiais

print("O brasil", "possui", "5", "titulos mundiais", end="OPA")
retorna: O brasil possui 5 titulos mundiaisOPA

O espaçador padrão é espaço e o end padrão é \n

Declaração de variáveis é sempre um nome e um valor, nunca só nome.
pais = "Italia"
quantidade = 4

print(pais, "ganhou", quantidade "titulos")
italia ganhou 4 titulos

type(item) retorna o tipo da variável item passado. Python assume os
tipos de variáveis de acordo com as atribuições, inclusive para 
troca de tipos. Tipagem dinâmica vs tipagem estática.

python usa Snake_Case, ou seja:
notas_de_aula
e não
notasDeAula (CamelCase)

For em python---------------------------------------------------------------

A sintaxe básica é:

for variavel in range(1,10):
	print(variavel)
Vai retornar os numeros de 1 a 9

for variavel in range(1,10, 2):
	print(variavel)
Vai retornar 1, 3, 5, 7, 9 ou seja, somar 2 a cada entrada.

A função range retorna o range de numeros que serão usados, é possível 
fazer:

for variavel in [1,2,3,4,5]:
	print(variavel)
Vai retornar os numeros de 1 a 5

Como o ultimo numero é exclusivo, é uma boa ideia usar:

for variavel in range(1,10+1):
	print(variavel)
Vai retornar os numeros de 1 a 10

Mais String-----------------------------------------------------------------
Inicialmente podemos escrever uma string com colchetes e chamar a função
format nessa string, passando para ela os valores que desejamos colocar
no lugar destes colchetes:
 
print("Tentativa {} de {}".format(3,10)
saída: Tentativa 3 de 10

Para trocar as ordens dos parametros é possível colocar o index
dos parâmetros dentro dos colchetes, lembrando que o primeiro
index é 0:

print("Tentativa {0} de {1}".format(3,10)
saída: Tentativa 10 de 3

Para avisar que dentro dos colchetes vem um float:

print("R$ {:f}".format(1.5)
saída: R$ 1.500000

Para formatar esse float com sempre duas casas após a virgula:

print("R$ {:.2f}".format(1.5)
saída: R$ 1.50

Para formatar esse float ce forma que os valores saiam encaixados:
Primeiro conto quantos caracteres tem o número ao total, depois
coloco esse valor após os dois pontos:

print("R$ {:7.2f}".format(1.5)
print("R$ {:7.2f}".format(1234.5)
print("R$ {:7.2f}".format(4.5)
saída: 
       R$    1.50
	   R$ 1234.50
       R$    4.50
	   
Queremos alinhar os pontos e preencher com 0:

print("R$ {:07.2f}".format(1.5)
print("R$ {:07.2f}".format(1234.5)
print("R$ {:07.2f}".format(4.5)
saída: 
       R$ 0001.50
	   R$ 1234.50
       R$ 0004.50
	   
{:07.2f} quer dizer: substitua por um float, de duas casas após a virgu
la, aí o ponto, aí 7 casas ao todo, preenchidos com 0

Para inteiro não fiz sentido usar nada após a virgula (já que é inteiro)
mas fazemos:

print("R$ {:07d}".format(5)
saída: R$ 0000005

print("R$ {:07d}".format(56)
saída: R$ 0000056

Sem zeros:

print("R$ {:7d}".format(56)
saída: R$      56

Para datas:
print("Data: {:2d}/{:2d}".format(9,4)
saída: Data: 9/ 4

Melhorando:
print("Hoje: {:02d}/{:02d}".format(9,4)
saída: Data: 09/04

print("Hoje: {:02d}/{:02d}".format(19,11)
saída: Data: 19/11

Para lembrar, na documentação:
https://docs.python.org/3/library/string.html#formatexamples

A partir da versão 3.6 do Python, foi adicionado um novo recurso para
realizar a interpolação de strings. Esse recurso é chamado de f-strings
ou formatted string literals.

Esse recurso funciona da seguinte forma. Vamos imaginar que temos uma 
variável nome:

>>> nome = 'Matheus'
>>> print(f'Meu nome é {nome}')
Meu nome é Matheus
Quando colocamos a letra f antes das aspas, informamos ao Python que esta
mos utilizando uma f-string. Dessa forma o Python consegue, em tempo de 
execução, captar a expressão que está entre chaves ({ }) e avaliá-la.

Além de variáveis, podemos passar também de funções e métodos:

>>> nome = 'Matheus'
>>> print(f'Meu nome é {nome.lower()}')
Meu nome é matheus

Seed------------------------------------------------------------------------
A função random sempre usa seed para gerar o número. Dado um seed o
numero gerado sempre é o mesmo:
 
>>> random.seed(100)
>>> random.randrange(1, 101)
19

Arredondamento--------------------------------------------------------------

A função round arredonda para o numero par mais próximo, sendo assim:
3.5 arredonda para 4
4.5 arredonda para 4

Divisão---------------------------------------------------------------------

O operador / SEMPRE devolve um float:

>>>  3 / 2
1.5

>>>  2 / 2
1.0

>>>  5 / 2
2.5

Já o operador // sempre retorna um int sem arredondar, ou seja, 
retorna a parte inteira da divisão:

>>>  3 // 2
1

>>>  5 // 2
2

Importar--------------------------------------------------------------------

Quando importamos um módulo a primeira coisa que Python faz é executar 
tudo o que estiver no modulo.

Quando executamos um arquivo diretamente (chama o arquivo no shell,
por exemplo) a variável __name__ recebe o valor "__main__", pq 
python diz que ela é o programa principal.

Quando um outro programa chama o arquivo, a variável __name__ recebe
outro valor, logo, quando quisermos que determinada função seja 
chamada tanto como funcao para um programa quanto como um programa
a parte, precisamos adicionar o seguinte ao fim do arquivo:

if (__name__ == "__main__"):
    nome_da_funcao()

Pronto! Agora se chamar no shell, __name__ será igual a 
__main__ e esse if chamará a função.

Se chamar como função a partir de outro programa a função será 
executada uma vez e __name__ receberá outro valor, garantindo
que a função não será executada 2x

Funções---------------------------------------------------------------------

Podemos definir funções com a palavra reservada def. a sintaxe é:

def jogar():
	e tudo depois do tab pertence a essa função
	
Exemplo:
def soma(a, b):
	return a + b
	
Se um arquivo é composto só de função ele não pode ser executado
"sozinho" mas sim deve ser chamado por algum outro arquivo

Para chamar:

Se a função esta no mesmo arquivo:
nome_da_funcao()
s = soma(3, 4) 

Se a função esta em outro arquivo:
import outro

outro.nome_da_funcao()
s = outro.soma(3, 4)

