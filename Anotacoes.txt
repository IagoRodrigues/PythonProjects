Aula 5----------------------------------------------------------------------

Para escrever usamos print(). print() aceita vários parâmetros, incluindo
um separador e um end para colocar entre parâmetros:

print("O brasil", "possui", "5", "titulos mundiais", sep="-")
retorna: O brasil-possui-5-titulos mundiais

print("O brasil", "possui", "5", "titulos mundiais", end="OPA")
retorna: O brasil possui 5 titulos mundiaisOPA

O espaçador padrão é espaço e o end padrão é \n

Declaração de variáveis é sempre um nome e um valor, nunca só nome.
pais = "Italia"
quantidade = 4

print(pais, "ganhou", quantidade "titulos")
italia ganhou 4 titulos

type(item) retorna o tipo da variável item passado. Python assume os
tipos de variáveis de acordo com as atribuições, inclusive para 
troca de tipos. Tipagem dinâmica vs tipagem estática.

python usa Snake_Case, ou seja:
notas_de_aula
e não
notasDeAula (CamelCase)

For em python---------------------------------------------------------------

A sintaxe básica é:

for variavel in range(1,10):
	print(variavel)
Vai retornar os numeros de 1 a 9

for variavel in range(1,10, 2):
	print(variavel)
Vai retornar 1, 3, 5, 7, 9 ou seja, somar 2 a cada entrada.

A função range retorna o range de numeros que serão usados, é possível 
fazer:

for variavel in [1,2,3,4,5]:
	print(variavel)
Vai retornar os numeros de 1 a 5

Como o ultimo numero é exclusivo, é uma boa ideia usar:

for variavel in range(1,10+1):
	print(variavel)
Vai retornar os numeros de 1 a 10

Mais String-----------------------------------------------------------------
Inicialmente podemos escrever uma string com colchetes e chamar a função
format nessa string, passando para ela os valores que desejamos colocar
no lugar destes colchetes:
 
print("Tentativa {} de {}".format(3,10)
saída: Tentativa 3 de 10

Para trocar as ordens dos parametros é possível colocar o index
dos parâmetros dentro dos colchetes, lembrando que o primeiro
index é 0:

print("Tentativa {0} de {1}".format(3,10)
saída: Tentativa 10 de 3

Para avisar que dentro dos colchetes vem um float:

print("R$ {:f}".format(1.5)
saída: R$ 1.500000

Para formatar esse float com sempre duas casas após a virgula:

print("R$ {:.2f}".format(1.5)
saída: R$ 1.50

Para formatar esse float ce forma que os valores saiam encaixados:
Primeiro conto quantos caracteres tem o número ao total, depois
coloco esse valor após os dois pontos:

print("R$ {:7.2f}".format(1.5)
print("R$ {:7.2f}".format(1234.5)
print("R$ {:7.2f}".format(4.5)
saída: 
       R$    1.50
	   R$ 1234.50
       R$    4.50
	   
Queremos alinhar os pontos e preencher com 0:

print("R$ {:07.2f}".format(1.5)
print("R$ {:07.2f}".format(1234.5)
print("R$ {:07.2f}".format(4.5)
saída: 
       R$ 0001.50
	   R$ 1234.50
       R$ 0004.50
	   
{:07.2f} quer dizer: substitua por um float, de duas casas após a virgu
la, aí o ponto, aí 7 casas ao todo, preenchidos com 0

Para inteiro não fiz sentido usar nada após a virgula (já que é inteiro)
mas fazemos:

print("R$ {:07d}".format(5)
saída: R$ 0000005

print("R$ {:07d}".format(56)
saída: R$ 0000056

Sem zeros:

print("R$ {:7d}".format(56)
saída: R$      56

Para datas:
print("Data: {:2d}/{:2d}".format(9,4)
saída: Data: 9/ 4

Melhorando:
print("Hoje: {:02d}/{:02d}".format(9,4)
saída: Data: 09/04

print("Hoje: {:02d}/{:02d}".format(19,11)
saída: Data: 19/11

Para lembrar, na documentação:
https://docs.python.org/3/library/string.html#formatexamples

A partir da versão 3.6 do Python, foi adicionado um novo recurso para
realizar a interpolação de strings. Esse recurso é chamado de f-strings
ou formatted string literals.

Esse recurso funciona da seguinte forma. Vamos imaginar que temos uma 
variável nome:

>>> nome = 'Matheus'
>>> print(f'Meu nome é {nome}')
Meu nome é Matheus
Quando colocamos a letra f antes das aspas, informamos ao Python que esta
mos utilizando uma f-string. Dessa forma o Python consegue, em tempo de 
execução, captar a expressão que está entre chaves ({ }) e avaliá-la.

Além de variáveis, podemos passar também de funções e métodos:

>>> nome = 'Matheus'
>>> print(f'Meu nome é {nome.lower()}')
Meu nome é matheus

Seed------------------------------------------------------------------------
A função random sempre usa seed para gerar o número. Dado um seed o
numero gerado sempre é o mesmo:
 
>>> random.seed(100)
>>> random.randrange(1, 101)
19

Arredondamento--------------------------------------------------------------

A função round arredonda para o numero par mais próximo, sendo assim:
3.5 arredonda para 4
4.5 arredonda para 4

Divisão---------------------------------------------------------------------

O operador / SEMPRE devolve um float:

>>>  3 / 2
1.5

>>>  2 / 2
1.0

>>>  5 / 2
2.5

Já o operador // sempre retorna um int sem arredondar, ou seja, 
retorna a parte inteira da divisão:

>>>  3 // 2
1

>>>  5 // 2
2

Importar--------------------------------------------------------------------

Quando importamos um módulo a primeira coisa que Python faz é executar 
tudo o que estiver no modulo.

Quando executamos um arquivo diretamente (chama o arquivo no shell,
por exemplo) a variável __name__ recebe o valor "__main__", pq 
python diz que ela é o programa principal.

Quando um outro programa chama o arquivo, a variável __name__ recebe
outro valor, logo, quando quisermos que determinada função seja 
chamada tanto como funcao para um programa quanto como um programa
a parte, precisamos adicionar o seguinte ao fim do arquivo:

if (__name__ == "__main__"):
    nome_da_funcao()

Pronto! Agora se chamar no shell, __name__ será igual a 
__main__ e esse if chamará a função.

Se chamar como função a partir de outro programa a função será 
executada uma vez e __name__ receberá outro valor, garantindo
que a função não será executada 2x

Funções---------------------------------------------------------------------

Podemos definir funções com a palavra reservada def. a sintaxe é:

def jogar():
	e tudo depois do tab pertence a essa função
	
Exemplo:
def soma(a, b):
	return a + b
	
Se um arquivo é composto só de função ele não pode ser executado
"sozinho" mas sim deve ser chamado por algum outro arquivo

Para chamar:

Se a função esta no mesmo arquivo:
nome_da_funcao()
s = soma(3, 4) 

Se a função esta em outro arquivo:
import outro

outro.nome_da_funcao()
s = outro.soma(3, 4)

Strings---------------------------------------------------------------------

Função find()------------------
palavra = "banana"
palavra.find("b")
retorna: 0

palavra.find("n")
retorna: 2

palavra.find("z")
retorna: -1

Se tiver a letra na palavra, retorna a primeira posição encontrada.

Função captalize()-------------
print(palavra.captalize())
retorna: "Banana"

Essa função retorna uma string com a primeira letra maiuscula e as outras
em minusculo

Função strip()-----------------
Essa função retira os espaços do início e do fim da string recebida e
retorna a string resultante.

Lists-----------------------------------------------------------------------

Python tem 3 tipos de listas: tuple, range e list:

Exemplos de list:
a = [1, 2, 3]
b = [2, 1, 3]

Acesso pelo index:
a[1]
2

list é ordenado (a é diferente de b mesmo contendo os mesmos valores)
pode conter qualquer tipo de item, inclusive mais de um tipo, e lists
podem ter o mesmo item mais de uma vez.

Podemos acessar elementos pelo index, podemos fatiar listas assim como
fatiamos strings:

>>> a = ['foo', 'bar', 'baz', 'qux', 'quux', 'corge']

>>> a[2:5]
['baz', 'qux', 'quux']

é possivel concatenar e multiplicar listas:
>>> a + ['grault', 'garply']
['foo', 'bar', 'baz', 'qux', 'quux', 'corge', 'grault', 'garply']

>>> a * 2
['foo', 'bar', 'baz', 'qux', 'quux', 'corge', 'foo', 'bar', 'baz',
'qux', 'quux', 'corge']

uma lista pode conter outra lista.

---TUPLE, STR E RANGE SÃO LISTS IMUTÁVEIS
 
O que muda entre list e tuple é que lists são dadas por [] e tuple são 
dadas por ():

>>> list = [4,3,2,1]
>>> tuple = (4,3,2,1)

Tenho a list "linhas_list" e quero tuple:
linhas_tuple = tuple(linhas_list)

Tenho a tuple "linhas_tuple" e quero list:
linhas_list = list(linhas_tuple)

---Existe ainda o elemento set:

>>> set = {4, 3, 2, 1}

o elemento set é como um list, mas não permite elementos repetidos nem
é ordenado, ou seja, ao imprimir um set não sabemos em qual ordem
os elementos serão repetidos.

---o Dictionary armezena um par chave : valor

instrutores = {'Nico' : 39, 'Flavio': 37, 'Marcos' : 30}

agora é possível fazer:

>>> instrutores['Flavio']
imprime: 37

List Comprehension----------------------------------------------------------

python permite inicializar uma lista já fazendo o laço para preenche-la:
se queremos preencher a lista com numeros de 1 a 5:

lista = [for var in range(1,6)]

Se temos a lista:
frutas = ["maçã", "banana", "laranja", "melancia"]

E queremos criar uma lista com as mesmas frutas em maiusculo fazemos:
lista = [fruta.upper() for fruta in frutas]

List Comprehension também permite utilizar condições para o 
preenchimento da lista.

temos uma lista de inteiros:
inteiros = [1,3,4,5,7,8,9]

queremos só os pares:
Forma 1:
pares = []
for numero in inteiros:
    if numero % 2 == 0:
        pares.append(numero)
		
Forma 2 com list comprehension:
pares = [x for x in inteiros if x % 2 == 0]